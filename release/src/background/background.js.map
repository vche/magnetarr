{"mappings":"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","sources":["<anon>","src/background/background.js","src/lib/provider.js","src/lib/server.js","node_modules/@parcel/node-resolver-core/lib/_empty.js"],"sourcesContent":["(() => {\n\"use strict\";\n\n\nconst $e1c11fc7383b8165$export$55be15701b71cf02 = {\n    Unknown: null,\n    Movie: \"movie\",\n    Serie: \"serie\"\n};\nclass $e1c11fc7383b8165$export$d59771a2e9612de9 {\n    constructor(name, default_port = 0){\n        this.name = name;\n        this.default_port = default_port;\n        this.setConfig();\n    }\n    // Configure server from config dictionary\n    setConfig(server_settings = null) {\n        // Create empty config if neede\n        if (server_settings == null) server_settings = {\n            configuration: {\n                auth: {}\n            },\n            preferences: {}\n        };\n        else {\n            if (server_settings.configuration === undefined) server_settings[\"configuration\"] = {\n                auth: {}\n            };\n            else if (server_settings.configuration.auth === undefined) server_settings.configuration[\"auth\"] = {};\n            if (server_settings.preferences === undefined) server_settings[\"preferences\"] = {};\n        }\n        // Set properties or use default\n        this.enabled = server_settings.enabled || false;\n        // Set server configuration\n        this.host = server_settings.configuration.host || \"http://127.0.0.1\";\n        this.port = server_settings.configuration.port || this.default_port;\n        this.apikey = server_settings.configuration.apikey || \"\";\n        this.user = server_settings.configuration.auth.user || \"\";\n        this.password = server_settings.configuration.auth.password || \"\";\n        // Set server preferences\n        this.monitored = server_settings.preferences.monitored || true;\n        this.profileid = server_settings.preferences.qualityProfileId || \"1\";\n        this.auxinfo = server_settings.preferences.auxInfo || \"1\";\n    }\n    // Get the server config dictionary\n    getConfig() {\n        return {\n            \"enabled\": this.enabled,\n            \"configuration\": {\n                \"host\": this.host,\n                \"port\": this.port,\n                \"apikey\": this.apikey,\n                \"auth\": {\n                    \"user\": this.user,\n                    \"pass\": this.password\n                }\n            },\n            \"preferences\": {\n                \"monitored\": this.monitored,\n                \"qualityProfileId\": this.profileid,\n                \"auxInfo\": this.auxinfo\n            }\n        };\n    }\n    // Load the config from the extension storage\n    loadConfig(callback = null) {\n        const wanted = {};\n        wanted[this.name] = this.getConfig();\n        chrome.storage.sync.get(wanted, (items)=>{\n            this.setConfig(items[this.name]);\n            console.debug(`Loaded ${this.name} config: ${JSON.stringify(this.getConfig())}`);\n            if (callback) callback(items);\n        });\n    }\n    // Save config to the extension storage\n    saveConfig(callback) {\n        const wanted = {};\n        wanted[this.name] = this.getConfig();\n        console.debug(`Saved ${this.name} config: ${JSON.stringify(this.getConfig())}`);\n        chrome.storage.sync.set(wanted, ()=>{\n            callback();\n        });\n    }\n    // Build the server url\n    getUrl() {\n        var regex = new RegExp(\"https{0,1}://\");\n        if (!regex.exec(this.host)) this.host = \"http://\" + this.host;\n        if (this.port === \"\") return this.host;\n        else return this.host + \":\" + this.port;\n    }\n    async get(endpoint, data = null, params = null) {\n        try {\n            // Build URL\n            var url = this.getUrl() + endpoint;\n            if (params) url = url + \"?\" + params;\n            // Build headers\n            const headers = {\n                \"X-Api-Key\": this.apikey\n            };\n            if (this.user && this.password) headers[\"Authorization\"] = \"Basic \" + btoa(this.user + \":\" + this.password);\n            // Build data\n            var body = data;\n            if (data != null && typeof data !== \"string\") body = JSON.stringify(data);\n            const res = await fetch(url, {\n                method: \"get\",\n                body: body,\n                headers: headers\n            });\n            if (res.status >= 400) throw new Error(`${res.status} (${res.statusText})`);\n            data = await res.json();\n            console.debug(`Request to ${url}: ${res.status} ${JSON.stringify(data)}`);\n            return data;\n        } catch (error) {\n            console.log(`Error querying endpoint ${url}: ${error}`);\n            throw error;\n        }\n    }\n    getLogo(size = \"48\") {\n        return `./img/${this.name}/${this.name}-${size}.png`;\n    }\n    itemUrlPath() {\n        return \"\";\n    }\n    checkItemId(itemid, item) {\n        return False;\n    }\n    async itemExists(itemid = null, itemslug = null) {\n        const response = await this.get(this.itemUrlPath());\n        for(var i = 0; i < response.length; i++){\n            const elt = response[i];\n            if (itemid && this.checkItemId(itemid, elt) || itemslug && itemslug === elt.titleSlug) return elt.titleSlug;\n        }\n    }\n    //     isExistingMovie(imdbid) {\n    //         var self = this;\n    //         return new Promise(function(resolve, reject) {\n    //             self.get(\"/api/v3/movie\", \"\").then(function(response) {\n    //                 for (var i = 0; i < response.text.length; i++) {\n    //                     if (imdbid === response.text[i].imdbId) {\n    //                         resolve(response.text[i].titleSlug);\n    //                     }\n    //                 }\n    //                 resolve(\"\");\n    //             }).catch(function(error) {\n    //                 reject(error);\n    //             });\n    //         });\n    //     }\n    // \tisExistingMovieByTitleSlug(titleSlug) {\n    // \t\tvar self = this;\n    // \t\treturn new Promise(function(resolve, reject) {\n    // \t\t\tself.get(\"/api/v3/movie\", \"\").then(function(response) {\n    // \t\t\t\tfor (var i = 0; i < response.text.length; i++) {\n    // \t\t\t\t\tif (titleSlug === response.text[i].titleSlug) {\n    // \t\t\t\t\t\tresolve(response.text[i].titleSlug);\n    // \t\t\t\t\t}\n    // \t\t\t\t}\n    // \t\t\t\tresolve(\"\");\n    // \t\t\t}).catch(function(error) {\n    // \t\t\t\treject(error);\n    // \t\t\t});\n    // \t\t});\n    // \t}\n    // }\n    // async isExistingSeries(tvdbid) {\n    //     var self = this;\n    //     return new Promise(function(resolve, reject) {\n    //         self.get(\"/api/v3/series\", \"\").then(function(response) {\n    //             for (var i = 0; i < response.text.length; i++) {\n    //                 if (tvdbid == response.text[i].tvdbId) {\n    //                     resolve(response.text[i].titleSlug);\n    //                 }\n    //             }\n    //             resolve(\"\");\n    //         }).catch(function(error) {\n    //             reject(error);\n    //         });\n    //     });\n    // }\n    // isExistingSeriesByTitleSlug(titleSlug) {\n    //     var self = this;\n    //     return new Promise(function(resolve, reject) {\n    //         self.get(\"/api/v3/series\", \"\").then(function(response) {\n    //             for (var i = 0; i < response.text.length; i++) {\n    //                 if (titleSlug === response.text[i].titleSlug) {\n    //                     resolve(response.text[i].titleSlug);\n    //                 }\n    //             }\n    //             resolve(\"\");\n    //         }).catch(function(error) {\n    //             reject(error);\n    //         });\n    //     });\n    // }\n    // }\n    async lookupItem(itemid) {\n        //if exist -> existing itemslug + movie\n        // if found: -> movie\n        const existing_elt = await this.itemExists(itemid);\n        // TODO: check if exist + lookup to get info to display !\n        // do both in // and wait for join ? hmm.....\n        if (existing_elt) console.log(\"yp pipo trouve: \" + existing_elt);\n        else console.log(\"yp pipo trouve: \" + existing_elt);\n    // Return: item_info + item_slug\n    // {\"type\": \"movie\", \"movie\": lookup, \"existingSlug\": existingSlug});\n    }\n}\nclass $e1c11fc7383b8165$export$245a76c709f13a9f extends $e1c11fc7383b8165$export$d59771a2e9612de9 {\n    constructor(){\n        super(\"radarr\", 7878);\n    }\n    itemUrlPath() {\n        return \"/api/v3/movie\";\n    }\n    checkItemId(itemid, item) {\n        return itemid === item.imdbId;\n    }\n}\nclass $e1c11fc7383b8165$export$8a63d9191f88983e extends $e1c11fc7383b8165$export$d59771a2e9612de9 {\n    constructor(){\n        super(\"sonarr\", 8989);\n    }\n    itemUrlPath() {\n        return \"/api/v3/series\";\n    }\n    checkItemId(itemid, item) {\n        return item.tvdbId && itemid === item.tvdbId.toString();\n    }\n}\n// global\n// post()\n// getProfiles()\n// getFolders()\n// openItem(itemslug)\n// use open_url \"/movies/\"\" or \"/series/\"\n// chrome.tabs.create({\n//     url: radarr.constructBaseUrl() + \"/movies/\" + media.existingSlug\n//     url: sonarr.constructBaseUrl() + \"/series/\" + media.existingSlug\n// });\n// addItem()\n// tbd\n// radarr.addMovie(\n//     media.movie.text[0],\n//     $('#lstProfile').val(),\n//     $('#monitored').prop('checked'),\n//     $('#lstMinAvail').val(),\n//     false,\n//     $('#lstFolderPath').val() ? $('#lstFolderPath').val() : addPath\n// );\n// sonarr.addSeries(\n//     media.series.text[0],\n//     $('#lstProfile').val(),\n//     $('#lstSeriesType').val(),\n//     $('#monitored').prop('checked'),\n//     false,\n//     $('#lstFolderPath').val() ? $('#lstFolderPath').val() : addPath,\n//     $('#lstLanguage').val()\n// );\n// lookupMovie(imdbid, tvdbid = \"\") {\n//     var self = this;\n//     // antipattern: resolve acts as reject and vice versa\n//     return new Promise(function(resolve, reject) {\n// \t\t// Cancel movie search if there a tvid. This means the imdb entry related to a valid tv show.\n// \t\t// This prevents issues where an imdb show also has a movie entry; e.g. tt6741278.\n// \t\t// The initial behavior was \"first answer wins\". This forces tv show entry over movie.\n//         if (imdbid === \"\" || tvdbid != \"\") {\n//             resolve();\n//         } else {\n//             var existingSlug = self.isExistingMovie(imdbid);\n//             var lookup = self.get(\"/api/v3/movie/lookup\", \"term=imdb%3A%20\" + imdbid);\n//             Promise.all([lookup, existingSlug]).then(function(response) {\n// \t\t\t\tconsole.log(\"movie lookup result:\");\n// \t\t\t\tconsole.log(response);\n// \t\t\t\tif (response[0].text.length == 0) resolve();\n//                 reject({\"type\": \"movie\", \"movie\": response[0], \"existingSlug\": response[1]});\n//             }).catch(function(error) {\n//                 resolve(error);\n//             });\n//         }\n//     });\n// }\n// async lookupSeries(tvdbid) {\n//     var self = this;\n//     // antipattern: resolve acts as reject and vice versa\n//     return new Promise(function(resolve, reject) {\n//         if (tvdbid === \"\") {\n//             resolve();\n//         } else {\n//             var existingSlug = self.isExistingSeries(tvdbid);\n//             var lookup = self.get(\"/api/v3/series/lookup\", \"term=tvdb%3A%20\" + tvdbid);\n//             Promise.all([lookup, existingSlug]).then(function(response) {\n// \t\t\t\tconsole.log(\"serie lookup result:\");\n// \t\t\t\tconsole.log(response);\n// \t\t\t\tif (response[0].text.length == 0) resolve();\n//                 reject({\"type\": \"series\", \"series\": response[0], \"existingSlug\": response[1]});\n//             }).catch(function(error) {\n//                 resolve(error);\n//             });\n//         }\n//     });\n// }\n// lookupItemByTitleYear(title, year)\n// async lookupMovieByTitleYear(title, year) {\n// \tvar self = this;\n// \tvar searchString = title + \" \" + year;\n// \tsearchString = encodeURI(searchString);\n// \t// antipattern: resolve acts as reject and vice versa\n// \treturn new Promise(async function(resolve, reject) {\n// \t\tif (title === \"\") {\n// \t\t\tresolve();\n// \t\t} else {\n// \t\t\tvar lookup = await self.get(\"/api/v3/movie/lookup\", \"term=\" + searchString)\n// \t\t\tvar existingSlug = await self.isExistingMovieByTitleSlug(lookup.text[0].titleSlug)\n// \t\t\tif (lookup) {\n// \t\t\t\treject({\"type\": \"movie\", \"movie\": lookup, \"existingSlug\": existingSlug});\n// \t\t\t} else {\n// \t\t\t\tresolve(error);\n// \t\t\t}\n// \t\t};\n// \t});\n// }\n// async lookupSeriesByTitleYear(title, year) {\n// \tvar self = this;\n// \tvar searchString = title + \" \" + year;\n// \tsearchString = encodeURI(searchString);\n// \t// antipattern: resolve acts as reject and vice versa\n// \treturn new Promise(async function(resolve, reject) {\n// \t\tif (title === \"\") {\n// \t\t\tresolve();\n// \t\t} else {\n// \t\t\tvar lookup = await self.get(\"/api/v3/series/lookup\", \"term=\" + searchString)\n// \t\t\tvar existingSlug = await self.isExistingSeriesByTitleSlug(lookup.text[0].titleSlug)\n// \t\t\tif (lookup) {\n// \t\t\t\treject({\"type\": \"series\", \"series\": lookup, \"existingSlug\": existingSlug});\n// \t\t\t} else {\n// \t\t\t\tresolve(error);\n// \t\t\t}\n// \t\t};\n// \t});\n// }\nconst $e1c11fc7383b8165$var$ServerList = {};\n$e1c11fc7383b8165$var$ServerList[$e1c11fc7383b8165$export$55be15701b71cf02.Movie] = new $e1c11fc7383b8165$export$245a76c709f13a9f();\n$e1c11fc7383b8165$var$ServerList[$e1c11fc7383b8165$export$55be15701b71cf02.Serie] = new $e1c11fc7383b8165$export$8a63d9191f88983e();\nfunction $e1c11fc7383b8165$export$ddaec4e6efa6a9f1(type) {\n    return $e1c11fc7383b8165$var$ServerList[type];\n}\n\n\nclass $d0175d9ba891ce1f$var$Provider {\n    static get name() {\n        return \"\";\n    }\n    constructor(name){\n        this.name = $d0175d9ba891ce1f$export$95ff3f2cef1aeda.name;\n    }\n    urlMatch(url) {\n        return false;\n    }\n    itemFromUrl(url) {\n        return {\n            itemid: 0,\n            itemtype: (0, $e1c11fc7383b8165$export$55be15701b71cf02).Unknown\n        };\n    }\n}\nclass $d0175d9ba891ce1f$export$95ff3f2cef1aeda extends $d0175d9ba891ce1f$var$Provider {\n    static get name() {\n        return \"Imdb\";\n    }\n    constructor(name){\n        super(name);\n        this.idRegex = new RegExp(\"/tt\\\\d{1,8}\");\n        this.xmlparser = new DOMParser();\n    }\n    urlMatch(url) {\n        return url.match(/\\/\\/www\\.imdb.com\\/.+\\/tt\\d{7,8}\\//) ? true : false;\n    }\n    imdbIdFromUrl(url) {\n        const imdbid = this.idRegex.exec(url);\n        return imdbid ? imdbid[0].slice(1) : \"\";\n    }\n    async tvdbidFromImdbid(imdbid) {\n        const url = \"http://thetvdb.com/api/GetSeriesByRemoteID.php?imdbid=\" + imdbid;\n        const headers = {\n            \"Content-Type\": \"application/xml\"\n        };\n        try {\n            // Try to get the serie id from allocine\n            const res = await fetch(url, {\n                method: \"get\",\n                headers: headers\n            });\n            if (res.status >= 400) throw new Error(`${res.status} (${res.statusText})`);\n            const xmldata = await res.text();\n            console.debug(`Request to ${url}: ${res.status} ${xmldata}`);\n            // Extract the serie id from xml data if we got some\n            const xmldoc = this.xmlparser.parseFromString(xmldata, \"application/xml\");\n            const errorNode = xmldoc.querySelector(\"parsererror\");\n            if (errorNode) console.log(\"error while parsing response: \" + xmldata);\n            else {\n                const serieid = xmldoc.getElementsByTagName(\"seriesid\");\n                if (serieid.length > 0) return serieid[0].innerHTML;\n            }\n        } catch (error) {\n            console.log(`Error querying endpoint ${url}: ${error}`);\n        }\n        return null;\n    }\n    async itemFromUrl(url) {\n        const imdbid = this.imdbIdFromUrl(url);\n        if (!imdbid) return {\n            itemid: null,\n            itemtype: (0, $e1c11fc7383b8165$export$55be15701b71cf02).Unknown\n        };\n        const tvdbid = await this.tvdbidFromImdbid(imdbid);\n        console.debug(\"imdb id \" + imdbid + \" // tvdb id \" + tvdbid);\n        // If we have a tvid, that's a serie. otherwise a movie\n        if (tvdbid) return {\n            itemid: tvdbid,\n            itemtype: (0, $e1c11fc7383b8165$export$55be15701b71cf02).Serie\n        };\n        return {\n            itemid: imdbid,\n            itemtype: (0, $e1c11fc7383b8165$export$55be15701b71cf02).Movie\n        };\n    }\n}\nclass $d0175d9ba891ce1f$export$cc923ee7e8796969 extends $d0175d9ba891ce1f$var$Provider {\n    static get name() {\n        return \"Tvdb\";\n    }\n    urlMatch(url) {\n        return url.match(/.*thetvdb.com\\/.*id\\=\\d{1,7}/) ? true : false;\n    }\n}\nclass $d0175d9ba891ce1f$export$3e3dab1427dcef9e extends $d0175d9ba891ce1f$var$Provider {\n    static get name() {\n        return \"RottenTomatoes\";\n    }\n    urlMatch(url) {\n        return url.match(/.*rottentomatoes.com\\/(tv|m)\\//) ? true : false;\n    }\n}\nclass $d0175d9ba891ce1f$export$d17694f8fb28c7d extends $d0175d9ba891ce1f$var$Provider {\n    static get name() {\n        return \"TheMovieDb\";\n    }\n    urlMatch(url) {\n        return url.match(/.*themoviedb.org\\/(tv|movie)\\//) ? true : false;\n    }\n}\nclass $d0175d9ba891ce1f$export$40e8b8a63495e688 extends $d0175d9ba891ce1f$var$Provider {\n    static get name() {\n        return \"TraktTv\";\n    }\n    urlMatch(url) {\n        return url.match(/.*trakt.tv\\/(shows|movies)\\//) ? true : false;\n    }\n}\n// Build the list of available providers\nconst $d0175d9ba891ce1f$var$ProviderList = {};\n$d0175d9ba891ce1f$var$ProviderList[$d0175d9ba891ce1f$export$95ff3f2cef1aeda.name] = new $d0175d9ba891ce1f$export$95ff3f2cef1aeda();\nfunction $d0175d9ba891ce1f$export$1284f32c93cfe5ef(url) {\n    for (const [name, provider] of Object.entries($d0175d9ba891ce1f$var$ProviderList)){\n        if (provider.urlMatch(url)) return provider;\n    }\n    return null;\n}\n\n\n\"use strict\";\nfunction $b61950db06f93f98$var$handlePageAction(tabInfo) {\n    chrome.tabs.query({\n        active: true,\n        currentWindow: true\n    }, function(tabArray) {\n        if (tabArray[0] && (0, $d0175d9ba891ce1f$export$1284f32c93cfe5ef)(tabArray[0].url)) chrome.action.enable(tabInfo.tabId);\n        else chrome.action.disable(tabInfo.tabId);\n    });\n}\n// Register our page parser when a tab gets activated and when a page gets loaded\nchrome.tabs.onActivated.addListener($b61950db06f93f98$var$handlePageAction);\nchrome.webNavigation.onCommitted.addListener($b61950db06f93f98$var$handlePageAction);\n\n})();\n//# sourceMappingURL=background.js.map\n","\"use strict\";\nimport {getProviderFromUrl} from \"../lib/provider\";\n\nfunction handlePageAction(tabInfo) {\n  chrome.tabs.query({active:true,currentWindow:true},function(tabArray){\n    if ((tabArray[0])&&(getProviderFromUrl(tabArray[0].url))) {\n        chrome.action.enable(tabInfo.tabId);\n    } else {\n        chrome.action.disable(tabInfo.tabId);\n    }\n  });\n}\n\n// Register our page parser when a tab gets activated and when a page gets loaded\nchrome.tabs.onActivated.addListener(handlePageAction);\nchrome.webNavigation.onCommitted.addListener(handlePageAction);\n","import { ItemTypes } from './server';\n\nclass Provider {\n    static get name() { return \"\"; }\n\n    constructor (name) {\n        this.name = Imdb.name;\n\t}\n    \n    urlMatch(url) { return false; }\n    itemFromUrl(url) { return {itemid: 0, itemtype: ItemTypes.Unknown}; }\n}\n\nexport class Imdb extends Provider {\n    static get name() { return \"Imdb\";}\n\n    constructor (name) {\n        super(name);\n        this.idRegex = new RegExp(\"\\/tt\\\\d{1,8}\");\n        this.xmlparser = new DOMParser();\n\t}\n\n    urlMatch(url) { return url.match(/\\/\\/www\\.imdb.com\\/.+\\/tt\\d{7,8}\\//)?true:false; }\n\n    imdbIdFromUrl(url) {\n        const imdbid = this.idRegex.exec(url);\n        return (imdbid) ? imdbid[0].slice(1) : \"\";\n    }\n\n    async tvdbidFromImdbid(imdbid) {\n        const url = \"http://thetvdb.com/api/GetSeriesByRemoteID.php?imdbid=\" + imdbid;\n        const headers = {\"Content-Type\": \"application/xml\"};\n        try {\n            // Try to get the serie id from allocine\n            const res = await fetch(url, { method: \"get\", headers: headers });\n            if (res.status >= 400) throw new Error(`${res.status} (${res.statusText})`)\n            const xmldata = await res.text();\n            console.debug(`Request to ${url}: ${res.status} ${xmldata}`); \n\n            // Extract the serie id from xml data if we got some\n            const xmldoc = this.xmlparser.parseFromString(xmldata, \"application/xml\");\n            const errorNode = xmldoc.querySelector(\"parsererror\");\n            if (errorNode) {\n              console.log(\"error while parsing response: \" + xmldata);\n            } else {\n                const serieid = xmldoc.getElementsByTagName(\"seriesid\");\n                if (serieid.length > 0) {\n                    return serieid[0].innerHTML;\n                }\n            }\n        } catch (error) {\n            console.log(`Error querying endpoint ${url}: ${error}`);\n        }\n        return null;\n    }\n\n    async itemFromUrl(url) {\n        const imdbid = this.imdbIdFromUrl(url);\n        if (!imdbid) {\n            return {itemid: null, itemtype: ItemTypes.Unknown}\n        }\n\n        const tvdbid = await this.tvdbidFromImdbid(imdbid)\n        console.debug(\"imdb id \" + imdbid + \" // tvdb id \" + tvdbid);\n\n        // If we have a tvid, that's a serie. otherwise a movie\n        if (tvdbid){\n            return {itemid: tvdbid, itemtype: ItemTypes.Serie}\n        }\n        return {itemid: imdbid, itemtype: ItemTypes.Movie}\n    }\n\n        // async ImdbidFromTitle(title,ismovie) {\n\t// \tif (ismovie){\n\t// \t\tvar url = \"http://www.imdb.com/find?s=tt&ttype=ft&ref_=fn_ft&q=\" + title;\n\t// \t} else {\n\t// \t\tvar url = \"http://www.imdb.com/find?s=tt&&ttype=tv&ref_=fn_tv&q=\" + title;\n\t// \t}\n\t// \tlet result = await $.ajax({url: url, datatype: \"xml\"});\n\t// \tvar regex = new RegExp(\"\\/tt\\\\d{1,8}\");\n\t// \tlet imdbid = await regex.exec($(result).find(\".result_text\").find(\"a\").attr(\"href\"));\n\n\t// \treturn (imdbid) ? imdbid[0].slice(1) : \"\";\n\n\t// }\n        // try {\n        //     let imdbid = pulsarr.extractIMDBID(url);\n        //     let tvdbid = await pulsarr.TvdbidFromImdbid(imdbid);\n        //     console.log(\"Extracted imdb id \" + imdbid + \" tvdbid \" + tvdbid);\n    \n        //     Promise.all([radarr.lookupMovie(imdbid, tvdbid), sonarr.lookupSeries(tvdbid)]).then(function(error) {\n        //         if (pulsarrConfig.radarr.isEnabled && pulsarrConfig.sonarr.isEnabled) {\n        //             pulsarr.info(error);\n        //         } else if (pulsarrConfig.radarr.isEnabled && !pulsarrConfig.sonarr.isEnabled) {\n        //             pulsarr.init(blackhole);\n        //             $('#optLgConfig').removeClass(\"hidden\");\n        //             pulsarr.info(\"Unable to find movie. If this is a series, please configure a Sonarr server.\");\n        //         } else if (!pulsarrConfig.radarr.isEnabled && pulsarrConfig.sonarr.isEnabled) {\n        //             pulsarr.init(blackhole);\n        //             $('#optLgConfig').removeClass(\"hidden\");\n        //             pulsarr.info(\"Unable to find series. If this is a movie, please configure a Radarr server.\");\n        //         } else {\n        //             chrome.runtime.openOptionsPage();\n        //         }\n        //     }).catch(function(response) {\n        //         pulsarr.init(response);\n        //     });\n        // } catch (err) {\n        //     pulsarr.info(err);\n        // }\n\n    //     return true; \n    // }\n}\n\nexport class Tvdb extends Provider {\n    static get name() { return \"Tvdb\";}\n\n    urlMatch(url) { return url.match(/.*thetvdb.com\\/.*id\\=\\d{1,7}/)?true:false; }\n\n    // tvdbIdFromUrl(url) {}\n    // var regex = new RegExp(\"(&|\\\\?)(id|seriesid)=\\\\d{1,7}\");\n    // var tvdbid = regex.exec(url);\n    // return (tvdbid) ? tvdbid[0].split(\"=\")[1]:\"\";\n}\n\nexport class RottenTomatoes extends Provider {\n    static get name() { return \"RottenTomatoes\";}\n\n    urlMatch(url) { return url.match(/.*rottentomatoes.com\\/(tv|m)\\//)?true:false; }\n}\n\nexport class TheMovieDb extends Provider {\n    static get name() { return \"TheMovieDb\";}\n\n    urlMatch(url) { return url.match(/.*themoviedb.org\\/(tv|movie)\\//)?true:false; }\n}\n\nexport class TraktTv extends Provider {\n    static get name() { return \"TraktTv\";}\n\n    urlMatch(url) { return url.match(/.*trakt.tv\\/(shows|movies)\\//)?true:false; }\n}\n\n// Build the list of available providers\nconst ProviderList = {};\nProviderList[Imdb.name] = new Imdb();\n// ProviderList[Tvdb.name] = new Tvdb();\n// ProviderList[RottenTomatoes.name] = new RottenTomatoes();\n// ProviderList[TheMovieDb.name] = new TheMovieDb();\n// ProviderList[TraktTv.name] = new TraktTv();\n\n// Find a provider matching this url\nexport function getProviderFromUrl(url) {\n    for (const [name, provider] of Object.entries(ProviderList)) {\n        if (provider.urlMatch(url)) { return provider; }\n    }\n    return null;\n}\n","import { lookupService } from \"dns\";\n\nexport const ItemTypes = {\n    Unknown: null,\n\tMovie: \"movie\",\n\tSerie: \"serie\",\n}\n\nexport class Server {\n\tconstructor (name, default_port=0) {\n\t\tthis.name = name;\n\t\tthis.default_port = default_port;\n        this.setConfig();\n\t}\n\n    // Configure server from config dictionary\n    setConfig(server_settings = null) {\n        // Create empty config if neede\n        if (server_settings == null) server_settings = {configuration: {auth: {}}, preferences: {}};\n        else {\n            if (server_settings.configuration === undefined) server_settings[\"configuration\"] = {auth: {}};\n            else if (server_settings.configuration.auth === undefined) server_settings.configuration[\"auth\"] = {};\n            if (server_settings.preferences === undefined) server_settings[\"preferences\"] = {};\n        }\n\n        // Set properties or use default\n        this.enabled = server_settings.enabled || false;\n\n        // Set server configuration\n        this.host = server_settings.configuration.host || \"http://127.0.0.1\";\n        this.port = server_settings.configuration.port || this.default_port;\n        this.apikey = server_settings.configuration.apikey || \"\" ;\n        this.user = server_settings.configuration.auth.user || \"\" ;\n        this.password = server_settings.configuration.auth.password || \"\" ;\n\n        // Set server preferences\n        this.monitored = server_settings.preferences.monitored || true ;\n        this.profileid = server_settings.preferences.qualityProfileId || \"1\" ;\n        this.auxinfo = server_settings.preferences.auxInfo || \"1\" ;\n    }\n\n    // Get the server config dictionary\n    getConfig() {\n\t    return {\n\t\t    \"enabled\": this.enabled,\n            \"configuration\": {\n                \"host\": this.host,\n                \"port\": this.port,\n                \"apikey\": this.apikey,\n                \"auth\": {\n                    \"user\": this.user,\n                    \"pass\": this.password,\n                }\n            },\n\t\t    \"preferences\": {\n\t\t\t    \"monitored\": this.monitored,\n\t\t\t    \"qualityProfileId\": this.profileid,\n\t\t\t    \"auxInfo\": this.auxinfo, // min availability for movies, series type for series\n            },\n        }\n    }\n\n    // Load the config from the extension storage\n    loadConfig(callback = null) {\n        const wanted = {}\n        wanted[this.name] = this.getConfig()\n        chrome.storage.sync.get(\n          wanted,\n            (items) => {\n              this.setConfig(items[this.name]);\n              console.debug(`Loaded ${this.name} config: ${JSON.stringify(this.getConfig())}`);\n              if (callback) callback(items);\n            }\n        );\n    }\n\n    // Save config to the extension storage\n    saveConfig(callback) {\n        const wanted = {}\n        wanted[this.name] = this.getConfig()\n        console.debug(`Saved ${this.name} config: ${JSON.stringify(this.getConfig())}`);\n        chrome.storage.sync.set(\n            wanted, \n            () => { callback(); }\n        );\n    }\n\n    // Build the server url\n    getUrl() {\n\t\tvar regex = new RegExp(\"https{0,1}:\\/\\/\");\n\n\t\tif (!regex.exec(this.host)) {\n\t\t\tthis.host = \"http://\" + this.host;\n\t\t}\n\t\tif (this.port === \"\") {\n\t\t\treturn this.host;\n\t\t} else {\n\t\t\treturn this.host + \":\" + this.port;\n\t\t}\n\t}\n\n    async get(endpoint, data=null, params=null) {\n        try {\n            // Build URL\n\t\t\tvar url = this.getUrl() + endpoint;\n            if (params) {\n\t\t\t    url = url + \"?\" + params;\n            }\n\n            // Build headers\n            const headers = {\"X-Api-Key\": this.apikey};\n\t\t\tif (this.user && this.password) {\n                headers[\"Authorization\"] = \"Basic \" + btoa(this.user + \":\" + this.password);\n            }\n\n            // Build data\n            var body = data;\n            if ((data != null) && (typeof data !== \"string\")) {\n                body = JSON.stringify(data);\n            }\n        \n            const res = await fetch(url, { method: \"get\", body: body, headers: headers });\n\n            if (res.status >= 400) throw new Error(`${res.status} (${res.statusText})`)\n            data = await res.json();\n            console.debug(`Request to ${url}: ${res.status} ${JSON.stringify(data)}`); \n\n            return data;\n        } catch (error) {\n            console.log(`Error querying endpoint ${url}: ${error}`);\n            throw error;\n        }\n    }\n\n    getLogo(size=\"48\") {\n        return `./img/${this.name}/${this.name}-${size}.png`;\n    }\n\n    itemUrlPath() { return \"\"; }\n    checkItemId(itemid, item) { return False}\n\n    async itemExists(itemid = null, itemslug = null) {\n        const response = await this.get(this.itemUrlPath());\n        for (var i = 0; i < response.length; i++) {\n            const elt = response[i];\n            if ((itemid && this.checkItemId(itemid, elt)) || (itemslug && itemslug === elt.titleSlug)) {\n                return elt.titleSlug;\n            }\n        }\n    }\n    //     isExistingMovie(imdbid) {\n    //         var self = this;\n    //         return new Promise(function(resolve, reject) {\n    //             self.get(\"/api/v3/movie\", \"\").then(function(response) {\n    //                 for (var i = 0; i < response.text.length; i++) {\n    //                     if (imdbid === response.text[i].imdbId) {\n    //                         resolve(response.text[i].titleSlug);\n    //                     }\n    //                 }\n    //                 resolve(\"\");\n    //             }).catch(function(error) {\n    //                 reject(error);\n    //             });\n    //         });\n    //     }\n\n    // \tisExistingMovieByTitleSlug(titleSlug) {\n    // \t\tvar self = this;\n    // \t\treturn new Promise(function(resolve, reject) {\n    // \t\t\tself.get(\"/api/v3/movie\", \"\").then(function(response) {\n    // \t\t\t\tfor (var i = 0; i < response.text.length; i++) {\n    // \t\t\t\t\tif (titleSlug === response.text[i].titleSlug) {\n    // \t\t\t\t\t\tresolve(response.text[i].titleSlug);\n    // \t\t\t\t\t}\n    // \t\t\t\t}\n    // \t\t\t\tresolve(\"\");\n    // \t\t\t}).catch(function(error) {\n    // \t\t\t\treject(error);\n    // \t\t\t});\n    // \t\t});\n    // \t}\n    // }\n    // async isExistingSeries(tvdbid) {\n    //     var self = this;\n    //     return new Promise(function(resolve, reject) {\n    //         self.get(\"/api/v3/series\", \"\").then(function(response) {\n    //             for (var i = 0; i < response.text.length; i++) {\n    //                 if (tvdbid == response.text[i].tvdbId) {\n    //                     resolve(response.text[i].titleSlug);\n    //                 }\n    //             }\n    //             resolve(\"\");\n    //         }).catch(function(error) {\n    //             reject(error);\n    //         });\n    //     });\n    // }\n\n    // isExistingSeriesByTitleSlug(titleSlug) {\n    //     var self = this;\n    //     return new Promise(function(resolve, reject) {\n    //         self.get(\"/api/v3/series\", \"\").then(function(response) {\n    //             for (var i = 0; i < response.text.length; i++) {\n    //                 if (titleSlug === response.text[i].titleSlug) {\n    //                     resolve(response.text[i].titleSlug);\n    //                 }\n    //             }\n    //             resolve(\"\");\n    //         }).catch(function(error) {\n    //             reject(error);\n    //         });\n    //     });\n    // }\n    // }\n    async lookupItem(itemid) {\n        //if exist -> existing itemslug + movie\n        // if found: -> movie\n\n        const existing_elt = await this.itemExists(itemid=itemid);\n\n        // TODO: check if exist + lookup to get info to display !\n        // do both in // and wait for join ? hmm.....\n        if (existing_elt) {\n            console.log(\"yp pipo trouve: \" + existing_elt)\n            // {\"type\": \"movie\", \"movie\": lookup, \"existingSlug\": existingSlug});\n        }\n        else {\n            console.log(\"yp pipo trouve: \" + existing_elt)\n            // {\"type\": \"movie\", \"movie\": lookup, \"existingSlug\": existingSlug});\n\n        }\n        // Return: item_info + item_slug\n        // {\"type\": \"movie\", \"movie\": lookup, \"existingSlug\": existingSlug});\n    }\n}\n\nexport class Radarr extends Server {\n\tconstructor () {\n        super(\"radarr\", 7878)\n    }\n\n    itemUrlPath() { return \"/api/v3/movie\"; }\n    checkItemId(itemid, item) {  return (itemid === item.imdbId); }\n}\n\nexport class Sonarr extends Server {\n\tconstructor () {\n        super(\"sonarr\", 8989)\n    }\n\n    itemUrlPath() { return \"/api/v3/series\"; }\n    checkItemId(itemid, item) { return ((item.tvdbId) && (itemid === item.tvdbId.toString())); }\n}\n\n\n// global\n// post()\n// getProfiles()\n// getFolders()\n// openItem(itemslug)\n    // use open_url \"/movies/\"\" or \"/series/\"\n    // chrome.tabs.create({\n    //     url: radarr.constructBaseUrl() + \"/movies/\" + media.existingSlug\n    //     url: sonarr.constructBaseUrl() + \"/series/\" + media.existingSlug\n    // });\n// addItem()\n    // tbd\n    // radarr.addMovie(\n    //     media.movie.text[0],\n    //     $('#lstProfile').val(),\n    //     $('#monitored').prop('checked'),\n    //     $('#lstMinAvail').val(),\n    //     false,\n    //     $('#lstFolderPath').val() ? $('#lstFolderPath').val() : addPath\n    // );\n    // sonarr.addSeries(\n    //     media.series.text[0],\n    //     $('#lstProfile').val(),\n    //     $('#lstSeriesType').val(),\n    //     $('#monitored').prop('checked'),\n    //     false,\n    //     $('#lstFolderPath').val() ? $('#lstFolderPath').val() : addPath,\n    //     $('#lstLanguage').val()\n    // );\n\n\n\n\n    // lookupMovie(imdbid, tvdbid = \"\") {\n    //     var self = this;\n    //     // antipattern: resolve acts as reject and vice versa\n    //     return new Promise(function(resolve, reject) {\n\t// \t\t// Cancel movie search if there a tvid. This means the imdb entry related to a valid tv show.\n\t// \t\t// This prevents issues where an imdb show also has a movie entry; e.g. tt6741278.\n\t// \t\t// The initial behavior was \"first answer wins\". This forces tv show entry over movie.\n    //         if (imdbid === \"\" || tvdbid != \"\") {\n    //             resolve();\n    //         } else {\n    //             var existingSlug = self.isExistingMovie(imdbid);\n    //             var lookup = self.get(\"/api/v3/movie/lookup\", \"term=imdb%3A%20\" + imdbid);\n    //             Promise.all([lookup, existingSlug]).then(function(response) {\n\t// \t\t\t\tconsole.log(\"movie lookup result:\");\n\t// \t\t\t\tconsole.log(response);\n\t// \t\t\t\tif (response[0].text.length == 0) resolve();\n    //                 reject({\"type\": \"movie\", \"movie\": response[0], \"existingSlug\": response[1]});\n    //             }).catch(function(error) {\n    //                 resolve(error);\n    //             });\n    //         }\n    //     });\n    // }\n    // async lookupSeries(tvdbid) {\n    //     var self = this;\n    //     // antipattern: resolve acts as reject and vice versa\n    //     return new Promise(function(resolve, reject) {\n    //         if (tvdbid === \"\") {\n    //             resolve();\n    //         } else {\n    //             var existingSlug = self.isExistingSeries(tvdbid);\n    //             var lookup = self.get(\"/api/v3/series/lookup\", \"term=tvdb%3A%20\" + tvdbid);\n    //             Promise.all([lookup, existingSlug]).then(function(response) {\n\t// \t\t\t\tconsole.log(\"serie lookup result:\");\n\t// \t\t\t\tconsole.log(response);\n\t// \t\t\t\tif (response[0].text.length == 0) resolve();\n    //                 reject({\"type\": \"series\", \"series\": response[0], \"existingSlug\": response[1]});\n    //             }).catch(function(error) {\n    //                 resolve(error);\n    //             });\n    //         }\n    //     });\n    // }\n\n// lookupItemByTitleYear(title, year)\n    // async lookupMovieByTitleYear(title, year) {\n\t// \tvar self = this;\n\t// \tvar searchString = title + \" \" + year;\n\t// \tsearchString = encodeURI(searchString);\n\t// \t// antipattern: resolve acts as reject and vice versa\n\t// \treturn new Promise(async function(resolve, reject) {\n\t// \t\tif (title === \"\") {\n\t// \t\t\tresolve();\n\t// \t\t} else {\n\t// \t\t\tvar lookup = await self.get(\"/api/v3/movie/lookup\", \"term=\" + searchString)\n\t// \t\t\tvar existingSlug = await self.isExistingMovieByTitleSlug(lookup.text[0].titleSlug)\n\t// \t\t\tif (lookup) {\n\t// \t\t\t\treject({\"type\": \"movie\", \"movie\": lookup, \"existingSlug\": existingSlug});\n\t// \t\t\t} else {\n\t// \t\t\t\tresolve(error);\n\t// \t\t\t}\n\t// \t\t};\n\t// \t});\n\t// }\n\t// async lookupSeriesByTitleYear(title, year) {\n\t// \tvar self = this;\n\t// \tvar searchString = title + \" \" + year;\n\t// \tsearchString = encodeURI(searchString);\n\t// \t// antipattern: resolve acts as reject and vice versa\n\t// \treturn new Promise(async function(resolve, reject) {\n\t// \t\tif (title === \"\") {\n\t// \t\t\tresolve();\n\t// \t\t} else {\n\t// \t\t\tvar lookup = await self.get(\"/api/v3/series/lookup\", \"term=\" + searchString)\n\t// \t\t\tvar existingSlug = await self.isExistingSeriesByTitleSlug(lookup.text[0].titleSlug)\n\t// \t\t\tif (lookup) {\n\t// \t\t\t\treject({\"type\": \"series\", \"series\": lookup, \"existingSlug\": existingSlug});\n\t// \t\t\t} else {\n\t// \t\t\t\tresolve(error);\n\t// \t\t\t}\n\t// \t\t};\n\t// \t});\n\t// }\n\nconst ServerList = {};\nServerList[ItemTypes.Movie] = new Radarr();\nServerList[ItemTypes.Serie] = new Sonarr();\n\n// Find a provider matching this url\nexport function getServerForType(type) {\n    return ServerList[type];\n}\n","\"use strict\";"],"names":["$e1c11fc7383b8165$export$55be15701b71cf02","Unknown","Movie","Serie","$e1c11fc7383b8165$export$d59771a2e9612de9","constructor","name","default_port","setConfig","server_settings","configuration","auth","preferences","undefined","enabled","host","port","apikey","user","password","monitored","profileid","qualityProfileId","auxinfo","auxInfo","getConfig","loadConfig","callback","wanted","chrome","storage","sync","get","items","console","debug","JSON","stringify","saveConfig","set","getUrl","regex","RegExp","exec","endpoint","data","params","url","headers","btoa","body","res","fetch","method","status","Error","statusText","json","error","log","getLogo","size","itemUrlPath","checkItemId","itemid","item","False","itemExists","itemslug","response","i","length","elt","titleSlug","lookupItem","$e1c11fc7383b8165$var$ServerList","imdbId","tvdbId","toString","$d0175d9ba891ce1f$var$Provider","$d0175d9ba891ce1f$export$95ff3f2cef1aeda","urlMatch","itemFromUrl","itemtype","idRegex","xmlparser","DOMParser","match","imdbIdFromUrl","imdbid","slice","tvdbidFromImdbid","xmldata","text","xmldoc","parseFromString","querySelector","serieid","getElementsByTagName","innerHTML","tvdbid","$d0175d9ba891ce1f$var$ProviderList","$b61950db06f93f98$var$handlePageAction","tabInfo","tabs","query","active","currentWindow","tabArray","provider","Object","entries","action","enable","tabId","disable","onActivated","addListener","webNavigation","onCommitted"],"version":3,"file":"background.js.map"}